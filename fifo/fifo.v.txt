`timescale 1ns/1ps

module FIFObuffer #(
  parameter DATA_WIDTH = 32,
  parameter DEPTH      = 16,
  parameter ADDR_WIDTH = $clog2(DEPTH)
)(
  input  wire                  Clk,
  input  wire                  Rst,
  input  wire                  EN,
  input  wire                  WR,
  input  wire                  RD,
  input  wire [DATA_WIDTH-1:0] dataIn,
  output reg  [DATA_WIDTH-1:0] dataOut,   // registered output
  output reg                   FULL,
  output reg                   EMPTY,
  output reg                   ALMOST_FULL,
  output reg                   ALMOST_EMPTY
);

  // Memory
  reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];
  reg [ADDR_WIDTH-1:0] w_ptr, r_ptr;
  reg [ADDR_WIDTH:0]   count;

  always @(posedge Clk) begin
    if (Rst) begin
      w_ptr        <= 0;
      r_ptr        <= 0;
      count        <= 0;
      dataOut      <= {DATA_WIDTH{1'b0}}; // reset to 0
      FULL         <= 1'b0;
      EMPTY        <= 1'b1;
      ALMOST_FULL  <= 1'b0;
      ALMOST_EMPTY <= 1'b1;
    end else if (EN) begin

      // Write
      if (WR && !FULL) begin
        mem[w_ptr] <= dataIn;
        w_ptr      <= w_ptr + 1'b1;
        count      <= count + 1'b1;
      end

      // Read
      if (RD && !EMPTY) begin
        dataOut <= mem[r_ptr];   // latch valid data
        r_ptr   <= r_ptr + 1'b1;
        count   <= count - 1'b1;
      end

      // Flags update
      FULL         <= (count == DEPTH);
      EMPTY        <= (count == 0);
      ALMOST_FULL  <= (count >= DEPTH-2);
      ALMOST_EMPTY <= (count <= 2);
    end
  end

endmodule
